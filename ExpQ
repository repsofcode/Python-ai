def isSafe(board, row, col):
    # Check this row on left side
    for i in range(col):
        if board[row][i]:
            return False

    # Check upper diagonal on left side
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j]:
            return False

    # Check lower diagonal on left side
    for i, j in zip(range(row, len(board)), range(col, -1, -1)):
        if board[i][j]:
            return False

    return True

def solve_queens(board, col, solutions):
    # If all queens are placed
    if col == len(board):
        solutions.append([row[:] for row in board])
        return

    # Consider this column and try placing this queen in all rows one by one
    for i in range(len(board)):
        if isSafe(board, i, col):
            board[i][col] = 1  # Place the queen

            # Recur to place rest of the queens
            solve_queens(board, col + 1, solutions)

            # If placing queen in board[i][col]
            # doesn't lead to a solution, remove queen (BACKTRACK)
            board[i][col] = 0

def print_board(board):
    for row in board:
        print(" ".join("Q" if x == 1 else "." for x in row))
    print()

def main():
    try:
        n = 4  # Change this value for different size of chessboard
        board = [[0 for _ in range(n)] for _ in range(n)]
        solutions = []
        solve_queens(board, 0, solutions)

        print(f"Found {len(solutions)} solutions:")
        for sol in solutions:
            print_board(sol)
    except Exception as e:
        print("An error occurred:", e)

main()
